
import * as fs from 'fs';
import * as path from 'path';
import { exec } from 'child_process';
import { Database } from 'better-sqlite3';
import { app } from 'electron';
import moment from 'moment';
import { generateReconciliationReport } from '../bank/report';

export interface ExportResult {
    path: string;
    filename: string;
}

export async function generateAccountantPack(db: Database, fromDate: string, toDate: string): Promise<ExportResult> {
    const timestamp = moment().format('YYYYMMDD_HHmmss');
    const rangeLabel = `${fromDate}_${toDate}`;
    const baseName = `accountant_pack_${rangeLabel}_${moment().format('YYYY-MM-DD')}`;
    
    // Setup temp directory
    const tempDir = path.join(app.getPath('userData'), 'temp', `export_${timestamp}`);
    if (!fs.existsSync(tempDir)) fs.mkdirSync(tempDir, { recursive: true });
    
    const packDir = path.join(tempDir, baseName);
    fs.mkdirSync(packDir);
    
    // 1. Generate README.txt
    const readmeContent = `
FETCH EXPANSE - ACCOUNTANT PACK
Generated: ${moment().format('YYYY-MM-DD HH:mm')}
Period: ${fromDate} to ${toDate}
Currency: ILS (Primary)

CONTENTS:
1. summary.csv
   - A list of all EXPENSES in the period.
   - Includes date, vendor, amount, description, and link to evidence.

2. expenses/
   - Organized by Month (YYYY-MM).
   - Contains PDF/Image evidence for each expense.
   - Filenames match the "Vendor - Date - Amount" pattern for easy sorting.

3. bank_reconciliation/ (Optional)
   - Contains reconciliation reports if bank statements were imported and matched.

generated by FetchExpanse
    `.trim();
    fs.writeFileSync(path.join(packDir, 'README.txt'), readmeContent);

    // 2. Fetch Expenses
    const expenses = db.prepare(`
        SELECT m.*, 
               (SELECT COUNT(*) FROM evidence_items WHERE message_id = m.id) as evidence_count,
               tm.match_score, tm.match_reason,
               bt.id as bank_txn_id
        FROM messages m
        LEFT JOIN txn_matches tm ON m.id = tm.message_id
        LEFT JOIN bank_transactions bt ON tm.txn_id = bt.id
        WHERE m.label = 'EXPENSE'
        AND m.date_iso >= ? AND m.date_iso <= ?
        ORDER BY m.date_iso ASC
    `).all(fromDate, toDate) as any[];

    // 3. Generate summary.csv AND copy evidence
    const csvRows = [];
    csvRows.push([
        'expense_id', 'date', 'vendor', 'description', 'amount', 'currency', 
        'evidence_count', 'evidence_types', 'bank_matched', 'bank_match_score', 'notes'
    ].join(','));

    // Create expenses dir
    const expensesDir = path.join(packDir, 'expenses');
    if (!fs.existsSync(expensesDir)) fs.mkdirSync(expensesDir);

    for (const exp of expenses) {
        // Prepare CSV Data
        const vendor = exp.vendor_override || exp.clean_name || exp.from_domain || 'Unknown';
        const dateMonth = exp.date_iso.substring(0, 7); // YYYY-MM
        const desc = (exp.subject || '').replace(/,/g, ' ').substring(0, 100);
        
        let evidenceTypes = [];
        
        // Handle Evidence
        const evidences = db.prepare('SELECT * FROM evidence_items WHERE message_id = ?').all(exp.id) as any[];
        
        // Create Month Dir
        const monthDir = path.join(expensesDir, dateMonth);
        if (!fs.existsSync(monthDir)) fs.mkdirSync(monthDir);

        for (const ev of evidences) {
            evidenceTypes.push(ev.kind);
            if (fs.existsSync(ev.local_path)) {
                const ext = path.extname(ev.local_path);
                // Sanitize filename: Vendor__Date__Amount__Desc
                const safeVendor = vendor.replace(/[^a-zA-Z0-9]/g, '_');
                const safeDesc = desc.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 30);
                const safeAmount = exp.gpt_amount ? exp.gpt_amount.toString().replace('.', '-') : 'XXX';
                
                const newName = `${safeVendor}__${exp.date_iso}__${safeAmount}__${safeDesc}${ext}`;
                fs.copyFileSync(ev.local_path, path.join(monthDir, newName));
            }
        }
        // Also check if link capture (if not in evidence items but in links_json? usually captured as evidence_item)
        
        const row = [
            exp.id,
            exp.date_iso,
            `"${vendor}"`,
            `"${desc}"`,
            exp.gpt_amount || '',
            exp.currency || 'ILS', // fallback
            exp.evidence_count,
            evidenceTypes.join('|'),
            exp.bank_txn_id ? 'YES' : 'NO',
            exp.match_score || '',
            ''
        ];
        csvRows.push(row.join(','));
    }

    fs.writeFileSync(path.join(packDir, 'summary.csv'), csvRows.join('\n'));

    // 4. Bank Reconciliation (Iterate all accounts)
    const accounts = db.prepare('SELECT * FROM bank_accounts').all() as any[];
    if (accounts.length > 0) {
        const bankDir = path.join(packDir, 'bank_reconciliation');
        if (!fs.existsSync(bankDir)) fs.mkdirSync(bankDir);
        
        for (const acc of accounts) {
            try {
                // Check if any matches exist in range? Or just generate report.
                 // Generate report directly into bankDir
                 const generatedPath = generateReconciliationReport(db, acc.id, fromDate, toDate, bankDir);
                 
                 // Rename to include account name for friendliness
                 const friendlyName = `reconciliation_${acc.name.replace(/\s/g,'_')}_${fromDate}_${toDate}.csv`;
                 fs.renameSync(generatedPath, path.join(bankDir, friendlyName));
                 
            } catch (e) {
                console.warn(`Skipping bank report for ${acc.name}:`, e);
            }
        }
        // Remove dir if empty
        if (fs.readdirSync(bankDir).length === 0) fs.rmdirSync(bankDir);
    }

    // 5. Zip it
    const zipPath = path.join(tempDir, `${baseName}.zip`);
    
    // Use system zip. 
    // cwd to tempDir so zip contains just the folder
    return new Promise((resolve, reject) => {
        exec(`zip -r "${baseName}.zip" "${baseName}"`, { cwd: tempDir }, (error, stdout, stderr) => {
            if (error) {
                console.error('Zip error:', stderr);
                reject(error);
                return;
            }
            resolve({
                path: zipPath,
                filename: `${baseName}.zip`
            });
        });
    });
}
